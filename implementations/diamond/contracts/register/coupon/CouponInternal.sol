// SPDX-License-Identifier: MIT
// FeverTokens Contracts v1.0.0

pragma solidity ^0.8.20;

import { ICouponInternal } from "./ICouponInternal.sol";
import { CouponStorage } from "./CouponStorage.sol";
import { RegisterMetadataInternal } from "../metadata/RegisterMetadataInternal.sol";
import { ReentrancyGuard } from "../../security/ReentrancyGuard.sol";
import { ContextInternal } from "../../metatx/ContextInternal.sol";

abstract contract CouponInternal is ICouponInternal, RegisterMetadataInternal {
    /**
     * @dev Throws if called by any account other than the PAY_ROLE.
     */
    modifier onlyPAY_ROLE() {
        // TODO: Manage the pay role
        CouponStorage.Layout storage l = CouponStorage.layout();
        require(
            _isPay(_msgSender()),
            "Sender must be a Paying calculation agent"
        );
        _;
    }
    modifier onlyCST_ROLE() {
        CouponStorage.Layout storage l = CouponStorage.layout();
        require(_isCustodian(_msgSender()), "Sender must be Custodian");
        _;
    }

    function _initialize(
        uint256 couponDate,
        uint256 nbDays,
        uint256 recordDate,
        uint256 cutOfTime
    ) internal {
        CouponStorage.Layout storage l = CouponStorage.layout();
        // l.register = IRegister(registerContract);
        // l.register2 = ICouponSnapshotManagement(registerContract);
        // TODO : Activate  the pay role
        require(
            _isPay(_msgSender()),
            "Sender must be a Paying calculation agent"
        );
        require(
            _checkIfCouponDateExists(couponDate),
            "this couponDate does not exists"
        );
        l.couponDate = couponDate;
        l.nbDays = nbDays;
        l.recordDate = recordDate - (recordDate % (3600 * 24)); // remove the time if any
        l.cutOfTime = cutOfTime % (3600 * 24); // remove the date part if any
        l.payingAgent = _msgSender();
        l.status = CouponStatus.Draft;
        emit CouponChanged(
            // l.register,
            l.couponDate,
            l.status
        );
    }

    function _couponDate() internal view returns (uint256) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.couponDate;
    }

    function _nbDays() internal view returns (uint256) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.nbDays;
    }

    function _recordDate() internal view returns (uint256) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.recordDate;
    }

    function _cutOfTime() internal view returns (uint256) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.cutOfTime;
    }

    function _payingAgent() internal view returns (address) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.payingAgent;
    }

    function _getInvestorPayments(
        address _investor
    ) internal view returns (PaymentStatus) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        return l.investorPayments[_investor];
    }

    function _paymentIdForInvest(
        address _investor
    ) internal view returns (bytes8) {
        //TODO: could also be generated by the JS backend
        return bytes8(keccak256(abi.encodePacked(address(this), _investor)));
    }

    /**
        @dev this method interacts with the register it is linked to and sets the rgister current coupon date and timestamp
     */
    function _setDateAsCurrentCoupon() internal nonReentrant onlyPAY_ROLE {
        CouponStorage.Layout storage l = CouponStorage.layout();
        //when PA validate the coupon
        require(
            l.status == CouponStatus.Draft,
            "The coupon date can be modified only if the contract status is Draft"
        );
        require(
            _checkIfCouponDateExists(l.couponDate),
            "this couponDate does not exists"
        );

        _setCurrentCouponDate(l.couponDate, l.recordDate + l.cutOfTime);
        // get the timestamp when the coupon period is passed
        l.actualTimestamp = _currentSnapshotDatetime();
        l.status = CouponStatus.Ready;
        emit CouponChanged(
            // l.register,
            l.couponDate,
            l.status
        );
    }

    function _setNbDays(uint256 nbDays) internal onlyPAY_ROLE {
        CouponStorage.Layout storage l = CouponStorage.layout();
        require(
            l.status == CouponStatus.Draft,
            "The coupon date can be modified only if the contract status is Draft"
        );
        l.nbDays = nbDays;
    }

    function _setCutOffTime(
        uint256 recordDate,
        uint256 cutOfTime
    ) internal onlyPAY_ROLE {
        CouponStorage.Layout storage l = CouponStorage.layout();
        require(
            l.status == CouponStatus.Draft,
            "The coupon date can be modified only if the contract status is Draft"
        );
        l.recordDate = recordDate - (recordDate % (24 * 3600));
        l.cutOfTime = cutOfTime % (24 * 3600);
    }

    function _rejectCoupon() internal onlyPAY_ROLE {
        CouponStorage.Layout storage l = CouponStorage.layout();
        l.status = CouponStatus.Cancelled;
        emit CouponChanged(
            // l.register,
            l.couponDate,
            l.status
        );
    }

    function _getPaymentAmountForInvestor(
        address _investor
    ) internal view returns (uint256 paymentAmount) {
        CouponStorage.Layout storage l = CouponStorage.layout();
        // Calculate coupon amount with Formula of Coupon Amount = unitValue * _totalSupply * couponRate * nbDays / 360
        // Step 2 on process - https://user-images.githubusercontent.com/26713092/172685832-b507fd58-fd50-466f-b91e-93e4d9f80c50.png

        uint256 unitValue = _getBondUnitValue();
        uint256 couponRate = _getBondCouponRate();
        uint256 balance = _balanceOfCoupon(_investor, l.couponDate);
        uint256 couponAmount = (unitValue * balance * couponRate * l.nbDays) /
            360;
        /** @dev
         * returns :
         * couponAmount : result of the calcul
         * decimals : always 4
         */
        return (couponAmount);
    }

    function _getTotalPaymentAmount()
        internal
        view
        returns (uint256 paymentAmount)
    {
        CouponStorage.Layout storage l = CouponStorage.layout();
        // Calculate coupon amount with Formula of Coupon Amount = unitValue * _totalSupply * couponRate * nbDays / 360
        // Step 2 on process - https://user-images.githubusercontent.com/26713092/172685832-b507fd58-fd50-466f-b91e-93e4d9f80c50.png

        uint256 unitValue = _getBondUnitValue();
        uint256 couponRate = _getBondCouponRate();
        uint256 balance = _totalSupply();
        uint256 couponAmount = (unitValue * balance * couponRate * l.nbDays) /
            360;
        /** @dev
         * returns :
         * couponAmount : result of the calcul
         * decimals : always 4
         */
        return (couponAmount);
    }

    function _toggleCouponPayment(address _investor) internal {
        CouponStorage.Layout storage l = CouponStorage.layout();
        require(_investorsAllowed(_investor), "This investor is not allowed");

        // The status control is important here because the actualTimestamp is zero before the status gets Ready
        require(
            l.status == CouponStatus.Ready,
            "The status of the coupon should be Ready"
        );
        PaymentStatus initialStatus = l.investorPayments[_investor];

        if (_isCAK(_msgSender())) {
            //CAK can make tobepaid to paid for all investors
            if (l.investorPayments[_investor] == PaymentStatus.ToBePaid) {
                require(
                    block.timestamp > l.actualTimestamp,
                    "the coupon cut of time has not passed"
                );
                l.investorPayments[_investor] = PaymentStatus.Paid;
            }
            //CAK peut faire passer de paid à tobepaid pour tous les investors
            else if ((l.investorPayments[_investor] == PaymentStatus.Paid)) {
                l.investorPayments[_investor] = PaymentStatus.ToBePaid;
            } else {
                revert(
                    "The status of this investor's payment should be Paid or ToBePaid"
                );
            }
        } else if (_isCustodian(_msgSender())) {
            require(
                _investorCustodian(_investor) == _msgSender(),
                "You are not custodian of this investor"
            );
            //cust peut faire passer de paid à received pour ses investors
            if (l.investorPayments[_investor] == PaymentStatus.Paid) {
                l.investorPayments[_investor] = PaymentStatus.PaymentReceived;
            }
            //cust peut faire passer de received à paid pour ses investors
            else if (
                (l.investorPayments[_investor] == PaymentStatus.PaymentReceived)
            ) {
                l.investorPayments[_investor] = PaymentStatus.Paid;
            } else {
                revert("Invalid Coupon payment status");
            }
        } else revert("sender must be Central Account Keeper or Custodian");

        emit CouponPaymentStatusChanged(
            // l.register,
            l.couponDate,
            _investor,
            l.investorPayments[_investor],
            initialStatus
        );
    }
}
